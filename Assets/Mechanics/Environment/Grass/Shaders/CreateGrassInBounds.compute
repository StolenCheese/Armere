#pragma kernel CSMain



#define PI 3.141592

cbuffer CB{
    float4 grassPositionBoundsMinMax;
    float4 grassDensityUVMinMax;
    float4 grassSizeMinMax;
    float grassHeightScale;
    int chunkID;
    int seed;
    int densityLayer;
    int2 dispatchSize;
}; 


#include "MeshProperties.hlsl"
AppendStructuredBuffer<MeshProperties> _Grass;
Texture2D<float3> _Gradient;
SamplerState sampler_Gradient;

Texture2D<float4> _Density;
SamplerState sampler_Density;
Texture2D<unorm float> _Height;
SamplerState sampler_Height;


RWStructuredBuffer<uint> _IndirectArgs;

//----------------------------------------------------------------------------------------
///  2 out, 2 in...
float2 hash22(float2 p)
{
	float3 p3 = frac(float3(p.xyx) * float3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx+33.33);
    return frac((p3.xx+p3.yz)*p3.zy);
}



//----------------------------------------------------------------------------------------
//  1 out, 2 in...
float hash12(float2 p)
{
	float3 p3  = frac(float3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}


[numthreads(8,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {

    MeshProperties m = (MeshProperties)0;

    m.chunkID = chunkID;
    //Create the t value of the lerp for position and density uv
    float2 positionLerp = hash22(grassPositionBoundsMinMax.zw + id.xy+seed);

    float2 pos = lerp(grassPositionBoundsMinMax.xy,grassPositionBoundsMinMax.zw, positionLerp);
    float2 densityUV = lerp(grassDensityUVMinMax.xy,grassDensityUVMinMax.zw,positionLerp);
    

    //Perform rejection sampling on grass based on desired density at position
    float density = _Density.SampleLevel(sampler_Density, densityUV, 0)[densityLayer];
    float testValue = hash12(densityUV.xy + id.xy);

    if (testValue < density){

        m.position.xz = pos;
        m.position.y = _Height.SampleLevel(sampler_Height, densityUV, 0) * grassHeightScale ;

        m.size =  lerp(grassSizeMinMax.xy,grassSizeMinMax.zw, hash22(grassSizeMinMax.zw + id.xy));
        m.yRot = lerp(-PI,PI,hash12(grassPositionBoundsMinMax.zy + id.xy));

        m.color = _Gradient.SampleLevel(sampler_Gradient, float2(hash12(grassPositionBoundsMinMax.xw + id.xy),0) ,0);

        _Grass.Append(m);
    }
}