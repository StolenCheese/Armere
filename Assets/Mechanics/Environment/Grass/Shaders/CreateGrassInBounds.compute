#pragma kernel CSMain



#define PI 3.141592

cbuffer CB{
    float4 grassPositionBoundsMinMax;
    float4 grassDensityUVMinMax;
    float4 grassSizeMinMax;
    float2 grassHeightRange;
    int chunkID;
    int seed;
    float4 densityLayerWeights;
    int2 dispatchSize;
	int grassBladesOffset;
}; 


#include "MeshProperties.hlsl"
RWStructuredBuffer<MeshProperties> _Grass;

Texture2D<float3> _Gradient;
SamplerState sampler_Gradient;

Texture2D<float4> _Density;
SamplerState sampler_Density;
Texture2D<unorm half2> _Height;
SamplerState sampler_Height;


//----------------------------------------------------------------------------------------
///  2 out, 2 in...
float2 hash22(float2 p)
{
	float3 p3 = frac(float3(p.xyx) * float3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx+33.33);
    return frac((p3.xx+p3.yz)*p3.zy);
}



//----------------------------------------------------------------------------------------
//  1 out, 2 in...
float hash12(float2 p)
{
	float3 p3  = frac(float3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}


[numthreads(8,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {

    MeshProperties m = (MeshProperties)0;



	m.size =  lerp(grassSizeMinMax.xy,grassSizeMinMax.zw, hash22(grassSizeMinMax.zw + id.xy));
    //Create the t value of the lerp for position and density uv





    float2 positionLerp = hash22(grassPositionBoundsMinMax.xy + id.x  + m.size + seed);
    float2 densityUV = lerp(grassDensityUVMinMax.xy,grassDensityUVMinMax.zw,positionLerp);
        //Perform rejection sampling on grass based on desired density at position
    float4 densities = _Density.SampleLevel(sampler_Density, densityUV, 0) * densityLayerWeights;
	float density = densities.x + densities.y + densities.z + densities.w;
    float2 pos = lerp(grassPositionBoundsMinMax.xy,grassPositionBoundsMinMax.zw, positionLerp);

    float testValue = hash12(densityUV.xy + id.xy);

	//If the test value is lower than density, make chunkID 0 (destroy it)
	m.chunkID = int(testValue < density) * chunkID;
			
	m.position.xz = pos;

	//For some reason, heightmap x is added to heightmap y with different scalars
	float2 heightMapData = _Height.SampleLevel(sampler_Height, densityUV, 0) * 2;

	m.position.y = grassHeightRange.x + grassHeightRange.y * heightMapData.y + heightMapData.x * (grassHeightRange.y / 256);

	m.yRot = lerp(-PI,PI,hash12(grassPositionBoundsMinMax.zy + id.xy));

	m.color = _Gradient.SampleLevel(sampler_Gradient, float2(hash12(grassPositionBoundsMinMax.xw + id.xy),0) ,0);

	m.shrinkDistance =  hash12(seed + id.xy + m.size*100) * 0.5 + 0.5;

	_Grass[grassBladesOffset + id.x] = m;
    
}