#pragma kernel CSMain
#pragma kernel CSMain




cbuffer CB{
    float3 cameraPosition;
    float deltatime;

    float time;
	float3 windDirection;

    float2 viewRadiusMinMax;

    //int pushers;
    int2 dispatchSize;


}; 

#include "MeshProperties.hlsl"
#include "MatrixStruct.hlsl"
 

StructuredBuffer<MeshProperties> _Properties;
RWStructuredBuffer<MatrixStruct> _Output;



//StructuredBuffer<float4> _PusherPositions;


float4x4 Rotation(float z, float y, float x){
    return float4x4 (
        cos(x)*cos(y),cos(x)*sin(y)*sin(z)-sin(x)*cos(z),cos(x)*sin(y)*cos(z)+sin(x)*sin(z),0,
        sin(x)*cos(y),cos(x)*sin(y)*sin(z)-cos(x)*cos(z),cos(x)*sin(y)*sin(z)+cos(x)*sin(z),0,
        -sin(y), cos(y)*sin(z), cos(y)*cos(z),0,
        0,0,0,1
    );
}

float4x4 rotationMatrix(float3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return float4x4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}


float4x4 RotationY(float y){
    return float4x4 (
        cos(y),0,sin(y),0,
        0,1,0,0,
        -sin(y),0,cos(y),0,
        0,0,0,1
    );
}

// Rotation with angle (in radians) and axis
float4x4 AngleAxis4x4(float angle, float3 axis)
{
    float c, s;
    sincos(angle, s, c);

    float t = 1 - c;
    float x = axis.x;
    float y = axis.y;
    float z = axis.z;

    return float4x4(
        t * x * x + c,      t * x * y - s * z,  t * x * z + s * y,0,
        t * x * y + s * z,  t * y * y + c,      t * y * z - s * x,0,
        t * x * z - s * y,  t * y * z + s * x,  t * z * z + c,0,
		0,0,0,1
    );
}

#define pi 3.14159265359


inline float angle(float2 vec) {
    return atan2(vec.x, vec.y);
}

float Repeat(float t, float length)
{
    return clamp(t - floor(t / length) * length, 0.0f, length);
}
float LerpAngle(float a, float b, float t)
{
    float delta = Repeat((b - a), pi*2);
    return a + delta * saturate(t);
}


#include "noiseSimplex.cginc"


// For the sake of simplicity, only using 1, 1, 1 threads.
//lol no
[numthreads(THREADGROUPS,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {

    uint index = id.x;
	//Clear the output buffer
	//TODO: Never make this dumb mistake again
	//_Output[index] = (MatrixStruct)0;


	// In a transform matrix, the position (translation) vector is the last column.

	//float damp = 0;
	//float3 dampDir = float3(0.01,0,0);

	// #ifdef GRASS_PUSHERS
	// 	for (int i = 0; i < pushers; i++){
	// 		float effect =  distance(properties.position, _PusherPositions[i].xyz);
	// 		float radius = _PusherPositions[i].w;

	// 		effect = (radius- clamp(0.0, radius, effect))/radius;

	// 		damp = max(damp,effect);
	// 		dampDir += (properties.position - _PusherPositions[i].xyz) * effect;
	// 	}
	// #endif

	//float3 dampAxis = cross(normalize(dampDir),float3(0,1,0));

	// Scale and reverse distance so that we get a value which fades as it gets further away.
	// Max distance is 5.0.

	//_Properties[id.x].rotation.y += 1 * deltatime;


	
	// 			snoise(properties.position.xz*0.02 + time*0.1) * (1-damp) * 0.25 + pi,
	// 			snoise(properties.position.zx*0.02 + time*0.1) * (1-damp) * 0.25);

	// The amount of wind decreases as damp increases
	//_Properties[id.x].rotation.x += damp*pi* 0.5 +pi;

	
	uint placedIndex = index;
	//float4x4 dampRotation = rotationMatrix(dampAxis,-damp * pi *0.5);
	MeshProperties properties = _Properties[index];


	MatrixStruct output = (MatrixStruct)0;

	float4x4 rotation = AngleAxis4x4(properties.yRot,float3(0,1,0));

	float windStrength = length(windDirection);

	float2 size = properties.size;


	float x = snoise(properties.position.xz * 0.05 + float2(time,time) * 0.2) * 0.1;
	float t = snoise(properties.position.xz * 0.05 ) + time;
	t /= size.y;

	// Apply translation to existing matrix, which will be read in the shader.

	float distance = length(properties.position.xyz - cameraPosition) / properties.shrinkDistance;

	float view = smoothstep(viewRadiusMinMax.y,viewRadiusMinMax.x,distance );
	size.y *= view;
	//If over the threshold completely disappear it
	size.x *= 1 - step(viewRadiusMinMax.y,distance);


	float angle = 0;


	angle += x;
	// angle += sin(x) * 0.2 + 0.5;
	angle += sin(t*2) * 0.1 *size.y;
	angle += sin(t*8 ) * 0.025 *size.y;
	angle *= windStrength;

	rotation = mul(AngleAxis4x4(angle , windDirection / windStrength),rotation);
// float4x4 mat_local_r = Rotation(pi,0,0);


	// Create a new translation matrix which represents a move in a direction.
	float4x4 translation = float4x4(
		1, 0, 0, properties.position.x,
		0, 1, 0, properties.position.y,
		0, 0, 1, properties.position.z,
		0, 0, 0, 1
	);
	float4x4 scale = float4x4(
		size.x, 0, 0, 0,
		0, size.y, 0, 0,
		0, 0, size.x,0,
		0, 0, 0, 1
	);





	float4x4 worldTransform =mul(mul(translation, rotation),scale);

	output.worldTransform[0] = worldTransform[0];
	output.worldTransform[1] = worldTransform[1];
	output.worldTransform[2] = worldTransform[2];

	output.color = properties.color ;
	//output.chunkID = properties.chunkID;

	_Output[placedIndex] = output;

    //_Output[index].color = view;

    /* Just for demo gif.  Not actually very useful -- need to inverse rotation first.
    float4x4 rotation = float4x4(
        .999, -.01, 0, 0.1,
        .01, .999, 0, 0.1,
        0, 0, 1, 0.1,
        0, 0, 0, 1
    );
    _Properties[id.x].mat = mul(_Properties[id.x].mat, rotation);
    */
}